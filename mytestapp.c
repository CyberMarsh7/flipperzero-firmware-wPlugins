#include <furi.h>

#include <gui/gui.h>
#include <gui/icon_i.h>

/* generated by fbt from .png files in images folder */
#include <mytestapp_icons.h>

#define DISPLAY_WIDTH 128
#define DISPLAY_HEIGHT 64

#define FPS 30

typedef enum {
    MyEventTypeKey,
    MyEventTypeDone,
} MyEventType;

typedef struct {
    MyEventType type; // The reason for this event.
    InputEvent input; // This data is specific to keypress data.
} MyEvent;

typedef struct {
    // Player coordinates
    int x;

    // Direction of movement
    int xDirection;

    // Time of run (ms)
    int time;
} TestAppState;

typedef struct {
    FuriMessageQueue* queue; // Event queue
    FuriTimer* timer; // Timer for redrawing the screen
    ViewPort* view_port; // Input and draw callbacks
    Gui* gui; // Fullscreen view

    Icon* player; // Player ship

    TestAppState state; // Application data
} TestApp;

static void my_draw_callback(Canvas* canvas, void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    canvas_set_font(canvas, FontPrimary);
    canvas_draw_bitmap(canvas, app->state.x, 56, 13, 8, icon_get_data(app->player));
}

static void my_input_callback(InputEvent* input_event, void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    if(input_event->type == InputTypeShort) {
        if(input_event->key == InputKeyBack) {
            MyEvent event;
            event.type = MyEventTypeDone;
            furi_message_queue_put(app->queue, &event, FuriWaitForever);
        }
    } else if(input_event->type == InputTypePress) {
        if(input_event->key == InputKeyLeft) app->state.xDirection = -1;
        if(input_event->key == InputKeyRight) app->state.xDirection = 1;
    } else if(input_event->type == InputTypeRelease) {
        if(input_event->key == InputKeyLeft || input_event->key == InputKeyRight) {
            app->state.xDirection = 0;
        }
    }
}

static void timer_callback(void* context) {
    furi_assert(context);
    TestApp* app = (TestApp*)context;

    app->state.x = app->state.x + app->state.xDirection;

    if(app->state.x > DISPLAY_WIDTH) app->state.x = DISPLAY_WIDTH;
    if(app->state.x < 0) app->state.x = 0;

    app->state.time += 1;
}

int32_t mytestapp_app(void* p) {
    UNUSED(p);

    // ---------------
    //      Init
    // ---------------
    TestApp* app = (TestApp*)malloc(sizeof(TestApp));

    // Create event queue
    app->queue = furi_message_queue_alloc(8, sizeof(MyEvent));

    // Create view port
    app->view_port = view_port_alloc();
    view_port_draw_callback_set(app->view_port, my_draw_callback, app);
    view_port_input_callback_set(app->view_port, my_input_callback, app);
    view_port_set_orientation(app->view_port, ViewPortOrientationHorizontal);

    // Create gui
    app->gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(app->gui, app->view_port, GuiLayerFullscreen);

    // Create timer
    app->timer = furi_timer_alloc(timer_callback, FuriTimerTypePeriodic, app);
    furi_timer_start(app->timer, 1000 / FPS);

    // ---------------
    //      Setup
    // ---------------

    app->player = (Icon*)&I_player;
    app->state.x = (DISPLAY_WIDTH - icon_get_width(app->player)) / 2;
    app->state.xDirection = 0;
    app->state.time = 0;

    // ---------------
    //    Main loop
    // ---------------
    MyEvent event;
    while(true) {
        if(furi_message_queue_get(app->queue, &event, FuriWaitForever) == FuriStatusOk) {
            if(event.type == MyEventTypeDone) {
                break;
            }
        } else {
            break;
        }
    }

    // ---------------
    //     Cleanup
    // ---------------

    // Free resources
    furi_timer_free(app->timer);
    furi_message_queue_free(app->queue);
    view_port_enabled_set(app->view_port, false);
    gui_remove_view_port(app->gui, app->view_port);
    view_port_free(app->view_port);
    furi_record_close(RECORD_GUI);
    free(app);

    return 0;
}
